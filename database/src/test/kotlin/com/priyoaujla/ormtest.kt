package com.priyoaujla

import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Rule
import org.junit.Test
import java.math.BigDecimal
import java.sql.Connection
import java.sql.ResultSet
import java.util.*
import javax.sql.DataSource

class OrmTest {

    @JvmField
    @Rule
    val database = TestDatabase(before = ::setup, after = ::tearDown, databasePort = 9002)

    private val userTable: Table<User> = UserTable("user", database.dataSource)
    private val billTable: Table<Bill> = BillTable("bill", database.dataSource)

    private fun setup(connection: Connection) {
        connection.use {
            it.createStatement().executeUpdate("""CREATE TABLE user (
            | id INT NOT NULL IDENTITY,
            | name VARCHAR(255) NOT NULL,
            | age INT NOT NULL,
            | fav_colour VARCHAR(64),
            | PRIMARY KEY (id)
            | );
        """.trimMargin())

            it.createStatement().executeUpdate("""CREATE TABLE bill (
            | id VARCHAR(255) NOT NULL,
            | amount DOUBLE NOT NULL,
            | PRIMARY KEY (id)
            | );
        """.trimMargin())
        }
    }

    private fun tearDown(connection: Connection) {
        connection.use {
            it.createStatement().executeUpdate("""DROP TABLE user;""".trimMargin())
            it.createStatement().executeUpdate("""DROP TABLE bill;""".trimMargin())
        }
    }

    @Test
    fun `inserting and retrieving`() {
        val user = User(name = Name("Betty"), age = Age(23), favColour = Colour("Orange"))
        userTable.insert(user)
        val result = userTable.get(UserTable.idColumn to UserTable.idColumn.withValue(0))

        assertEquals(user, result)
    }

    @Test
    fun `inserting and updating`() {
        userTable.insert(User(name = Name("Betty"), age = Age(23), favColour = Colour("Orange")))
        val oldUser = userTable.get(UserTable.idColumn to UserTable.idColumn.withValue(0))!!
        val newUser = oldUser.copy(name = Name("Julie"), age = Age(55), favColour = Colour("Blue"))
        userTable.update(newUser)
        val result = userTable.get(UserTable.idColumn to UserTable.idColumn.withValue(0))

        assertEquals(newUser, result)
    }

    @Test
    fun `inserting and deleting`() {
        userTable.insert(User(name = Name("Betty"), age = Age(23), favColour = Colour("Orange")))
        userTable.delete(userTable.get(UserTable.idColumn to UserTable.idColumn.withValue(0))!!)

        assertNull(userTable.get(UserTable.idColumn to UserTable.idColumn.withValue(0)))
    }

    @Test
    fun `inserting nullable value`() {
        val user = User(name = Name("Betty"), age = Age(23), favColour = null)
        userTable.insert(user)
        val result = userTable.get(UserTable.idColumn to UserTable.idColumn.withValue(0))

        assertEquals(user, result)
    }

    @Test
    fun `inserting uuid based primary key`() {
        val uuid = UUID.randomUUID()
        val bill = Bill(id = uuid, amount = Money(BigDecimal.valueOf(23.01)))
        billTable.insert(bill)
        val result = billTable.get(BillTable.idColumn to BillTable.idColumn.withValue(uuid))!!

        assertEquals(bill.id, result.id)
        assertEquals(bill.amount.value.toDouble(), result.amount.value.toDouble(), 0.01)
    }
}


class UserTable(override val name: String, dataSource: DataSource) : Table<User>(dataSource) {

    companion object {
        val idColumn = AutoGeneratedKeyColumn(KeyColumn(IntColumn(ColumnName("id"))))
        val nameColumn = NameColumn()
        val ageColumn = AgeColumn()
        val favColourColumn = ColourColumn()
    }

    override val columns = setOf(
            idColumn,
            nameColumn,
            ageColumn,
            favColourColumn
    )

    override fun mapTo(thing: User): Set<ColumnValueSetter> {
        return mutableSetOf(
                nameColumn.withValue(thing.name),
                ageColumn.withValue(thing.age)
        ).apply {
            thing.favColour?.let { add(favColourColumn.withValue(it)) }
        }
    }

    override fun mapFrom(resultSet: ResultSet): User {
        return User(
                resultSet.getInt(idColumn.name.value),
                Name(resultSet.getString(nameColumn.name.value)),
                Age(resultSet.getInt(ageColumn.name.value)),
                resultSet.getString(favColourColumn.name.value)?.let { Colour(it) }
        )
    }

    override fun uniqueKey(thing: User) = idColumn.withValue(thing.id)
}

data class Name(val value: String)
data class NameColumn(
        override val name: ColumnName = ColumnName("name")
) : TypeColumn<Name> {

    private val delegate = StringColumn(name)

    override fun withValue(value: Name): ColumnValueSetter = delegate.withValue(value.value).copy(column = this)
}

data class Age(val value: Int)
data class AgeColumn(
        override val name: ColumnName = ColumnName("age")
) : TypeColumn<Age> {

    private val delegate = IntColumn(name)

    override fun withValue(value: Age): ColumnValueSetter = delegate.withValue(value.value).copy(column = this)
}

data class Colour(val value: String)
data class ColourColumn(
        override val name: ColumnName = ColumnName("fav_colour")
) : TypeColumn<Colour> {

    private val delegate = StringColumn(name)

    override fun withValue(value: Colour): ColumnValueSetter = delegate.withValue(value.value).copy(column = this)
}

data class User(val id: Int = 0, val name: Name, val age: Age, val favColour: Colour?)

data class Money(val value: BigDecimal)
data class AmountColumn(
        override val name: ColumnName = ColumnName("amount")
) : TypeColumn<Money> {

    private val delegate = BigDecimalColumn(name)

    override fun withValue(value: Money): ColumnValueSetter = delegate.withValue(value.value).copy(column = this)
}
data class UUIDColumn(
        override val name: ColumnName = ColumnName("id")
): TypeColumn<UUID> {

    private val delegate = StringColumn(name)

    override fun withValue(value: UUID): ColumnValueSetter = delegate.withValue(value.toString()).copy(column = this)
}
data class Bill(val id: UUID, val amount: Money)

class BillTable(override val name: String, dataSource: DataSource) : Table<Bill>(dataSource) {

    companion object {
        val idColumn = KeyColumn(UUIDColumn(ColumnName("id")))
        val amountColumn = AmountColumn()
    }

    override val columns = setOf(
            idColumn,
            amountColumn
    )

    override fun mapTo(thing: Bill): Set<ColumnValueSetter> {
        return mutableSetOf(
                idColumn.withValue(thing.id),
                amountColumn.withValue(thing.amount)
        )
    }

    override fun mapFrom(resultSet: ResultSet): Bill {
        return Bill(
                UUID.fromString(resultSet.getString(idColumn.name.value)),
                Money(resultSet.getBigDecimal(amountColumn.name.value))
        )
    }

    override fun uniqueKey(thing: Bill) = idColumn.withValue(thing.id)
}