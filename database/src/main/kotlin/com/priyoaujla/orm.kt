package com.priyoaujla

import java.math.BigDecimal
import java.sql.PreparedStatement
import java.sql.ResultSet
import javax.sql.DataSource


data class ColumnName(val value: String)
data class ColumnValueSetter(val column: Column, val setter: (Int, PreparedStatement) -> PreparedStatement)

interface Column {
    val name: ColumnName

    fun toColumnValue(value: Any, setter: (Int, PreparedStatement) -> PreparedStatement): ColumnValueSetter = ColumnValueSetter(this, setter)
}

interface TypeColumn<in T> : Column {

    fun withValue(value: T): ColumnValueSetter
}


data class StringColumn(override val name: ColumnName) : TypeColumn<String> {

    override fun withValue(value: String) = toColumnValue(value) { index, it ->
        it.apply {
            setString(index, value)
        }
    }
}

data class IntColumn(override val name: ColumnName) : TypeColumn<Int> {

    override fun withValue(value: Int) = toColumnValue(value) { index, it ->
        it.apply {
            setInt(index, value)
        }
    }
}

data class BigDecimalColumn(override val name: ColumnName) : TypeColumn<BigDecimal> {

    override fun withValue(value: BigDecimal) = toColumnValue(value) { index, it ->
        it.apply {
            setBigDecimal(index, value)
        }
    }
}

interface IdColumn<in T> : TypeColumn<T>

data class KeyColumn<in T>(val column: TypeColumn<T>) : IdColumn<T> {

    override val name: ColumnName get() = column.name

    override fun withValue(value: T): ColumnValueSetter {
        val delegate = column.withValue(value)
        return delegate.copy(column = this)
    }
}

data class AutoGeneratedKeyColumn<in T>(val column: KeyColumn<T>) : IdColumn<T> by column {
    override fun withValue(value: T): ColumnValueSetter {
        val delegate = column.withValue(value)
        return delegate.copy(column = this)
    }
}

abstract class Table<T>(private val dataSource: DataSource) {

    internal abstract val name: String
    internal abstract val columns: Set<Column>

    fun insert(thing: T) {
        val values = mapTo(thing)
        val nonAutoGeneratedColumns =
            columns.filter { it !is AutoGeneratedKeyColumn<*> }
                .filter { column ->  values.any { column == it.column } }
        if (values.all { nonAutoGeneratedColumns.contains(it.column) }) {

            this.dataSource.connection.use {
                val sqlInsert = """
                INSERT INTO ${name}(${nonAutoGeneratedColumns.map { it.name.value }.joinToString(", ")})
                    VALUES(${values.map { "?" }.joinToString(", ")});
            """.trimIndent()

                val preparedStatement = it.prepareStatement(sqlInsert)
                values.forEachIndexed { index, it ->
                    it.setter(index + 1, preparedStatement)
                }

                preparedStatement.execute()
            }
        } else {
            error("Oops something went wrong")
        }
    }

    fun update(thing: T) {
        val newValues = mapTo(thing) + uniqueKey(thing)
        val id = newValues.find { it.column is IdColumn<*> }
        if (id != null && columns.contains(id.column)) {

            this.dataSource.connection.use {
                val sqlUpdate = """
                UPDATE ${name}
                    SET ${newValues.filter { it.column !is AutoGeneratedKeyColumn<*> }.map { "${it.column.name.value} = ?" }.joinToString(", ")}
                    WHERE ${id.column.name.value} = ?
            """.trimIndent()

                val preparedStatement = it.prepareStatement(sqlUpdate)
                (newValues + id).forEachIndexed { index, it ->
                    it.setter(index + 1, preparedStatement)
                }

                preparedStatement.execute()
            }
        } else {
            error("uh oh! Couldn't update!")
        }
    }

    fun delete(thing: T) {
        val columnValue = uniqueKey(thing)
        val isAnIdentifier = columnValue.column is IdColumn<*>
        val tableHasSuchAColumn = columns.contains(columnValue.column)
        if (isAnIdentifier && tableHasSuchAColumn) {
            this.dataSource.connection.use {
                val sqlDelete = """
                    DELETE FROM ${name} WHERE ${columnValue.column.name.value} = ?
                """.trimIndent()

                val preparedStatement = it.prepareStatement(sqlDelete)
                columnValue.setter(1, preparedStatement)
                preparedStatement.executeUpdate()
            }
        } else {
            error("Column value is not a key or is not a valid column")
        }
    }

    fun get(id: Pair<IdColumn<*>, ColumnValueSetter>): T? {
        this.dataSource.connection.use {
            val sqlUpdate = """
                SELECT *
                    FROM ${name}
                    WHERE ${id.first.name.value} = ?
            """.trimIndent()

            val preparedStatement = it.prepareStatement(sqlUpdate)
            listOf(id.second).forEachIndexed { index, columnValue ->
                columnValue.setter(index + 1, preparedStatement)
            }

            return preparedStatement.executeQuery().use { resultSet ->
                if (resultSet.next()) {
                    mapFrom(resultSet)
                } else {
                    null
                }
            }
        }
    }

    internal abstract fun mapTo(thing: T): Set<ColumnValueSetter>
    internal abstract fun uniqueKey(thing: T): ColumnValueSetter
    internal abstract fun mapFrom(resultSet: ResultSet): T?
}