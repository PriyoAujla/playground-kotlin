package com.priyoaujla

import org.hsqldb.types.Types
import java.math.BigDecimal
import java.sql.Blob
import java.sql.PreparedStatement
import java.sql.ResultSet
import javax.sql.DataSource


data class ColumnName(val value: String)
data class ColumnValueSetter(
    val column: Column,
    val sqlValueString: String = "?",
    val setter: (Int, PreparedStatement) -> PreparedStatement
)

interface Column {
    val name: ColumnName

    fun toColumnValue(setter: (Int, PreparedStatement) -> PreparedStatement): ColumnValueSetter =
        ColumnValueSetter(this, setter = setter)
}

interface TypeColumn<in T> : Column {

    fun withValue(value: T?): ColumnValueSetter
}


data class StringColumn(override val name: ColumnName) : TypeColumn<String> {

    override fun withValue(value: String?) = toColumnValue { index, it ->
        it.apply {
            setString(index, value)
        }
    }
}

data class IntColumn(override val name: ColumnName) : TypeColumn<Int> {

    override fun withValue(value: Int?) = toColumnValue { index, it ->
        it.apply {
            value?.let { setInt(index, it) } ?: setNull(index, Types.SQL_INTEGER)
        }
    }
}

data class BigDecimalColumn(override val name: ColumnName) : TypeColumn<BigDecimal> {

    override fun withValue(value: BigDecimal?) = toColumnValue { index, it ->
        it.apply {
            value?.let { setBigDecimal(index, it) } ?: setNull(index, Types.SQL_DECIMAL)
        }
    }
}

data class BlobColumn(override val name: ColumnName) : TypeColumn<Blob> {

    override fun withValue(value: Blob?) = toColumnValue { index, it ->
        it.apply {
            setBlob(index, value)
        }
    }
}

interface IdColumn<in T> : TypeColumn<T>

data class KeyColumn<in T>(val column: TypeColumn<T>) : IdColumn<T> {

    override val name: ColumnName get() = column.name

    override fun withValue(value: T?): ColumnValueSetter {
        val delegate = column.withValue(value)
        return delegate.copy(column = this)
    }
}

data class AutoGeneratedKeyColumn<in T>(val column: KeyColumn<T>) : IdColumn<T> by column {
    override fun withValue(value: T?): ColumnValueSetter {
        val delegate = column.withValue(value)
        return delegate.copy(column = this)
    }
}

abstract class Table<T>(private val dataSource: DataSource, private val iterationPageSize: Int = 10) {

    internal abstract val name: String

    fun insert(thing: T) {
        val values = mapTo(thing)
            .filter { it.column !is AutoGeneratedKeyColumn<*> }
        if (values.isNotEmpty()) {
            this.dataSource.connection.use {
                val sqlInsert = """
                INSERT INTO ${name}(${values.map { it.column.name.value }.joinToString(", ")})
                    VALUES(${values.map { it.sqlValueString }.joinToString(", ")});
            """.trimIndent()

                val preparedStatement = it.prepareStatement(sqlInsert)
                values.forEachIndexed { index, it ->
                    it.setter(index + 1, preparedStatement)
                }

                preparedStatement.execute()
            }
        } else {
            error("No ids found")
        }
    }

    fun update(thing: T) {
        val columnValues = mapTo(thing)
        val newValues = columnValues.filter { it.column !is IdColumn<*> }
        val ids = columnValues.filter { it.column is IdColumn<*> }
        if (ids.isNotEmpty()) {
            this.dataSource.connection.use {
                val sqlUpdate = """
                UPDATE $name
                    SET ${newValues.map { "${it.column.name.value} = ${it.sqlValueString}" }.joinToString(", ")}
                    WHERE ${ids.map { "${it.column.name.value} = ${it.sqlValueString}" }.joinToString(" AND ")}
            """.trimIndent()

                val preparedStatement = it.prepareStatement(sqlUpdate)
                (newValues + ids).forEachIndexed { index, it ->
                    it.setter(index + 1, preparedStatement)
                }

                preparedStatement.execute()
            }
        } else {
            error("No ids found")
        }
    }

    fun delete(thing: T) {
        val ids = mapTo(thing).filter { it.column is IdColumn<*> }
        if (ids.isNotEmpty()) {
            this.dataSource.connection.use {
                val sqlDelete = """
                    DELETE FROM $name WHERE ${
                    ids.map { "${it.column.name.value} = ${it.sqlValueString}" }.joinToString(" AND ")
                }
                """.trimIndent()

                val preparedStatement = it.prepareStatement(sqlDelete)
                ids.forEachIndexed { index, it ->
                    it.setter(index + 1, preparedStatement)
                }
                preparedStatement.executeUpdate()
            }
        } else {
            error("No ids found")
        }
    }

    fun get(vararg ids: ColumnValueSetter): T? {
        this.dataSource.connection.use {
            val sqlUpdate = """
                SELECT *
                    FROM $name
                    WHERE ${ids.map { "${it.column.name.value} = ${it.sqlValueString}" }.joinToString(" AND ")}
            """.trimIndent()

            val preparedStatement = it.prepareStatement(sqlUpdate)
            ids.forEachIndexed { index, id -> id.setter(index + 1, preparedStatement) }

            return preparedStatement.executeQuery().use { resultSet ->
                if (resultSet.next()) {
                    mapFrom(resultSet)
                } else {
                    null
                }
            }
        }
    }

    fun findBy(vararg withValues: ColumnValueSetter): Sequence<T> {
        val count = countRows()
        var page = Page(number = 0, size = iterationPageSize, total = count)
        return generateSequence {
            if (page.offset() <= page.total) {
                dataSource.connection.use {
                    val sql = selectByOffset(*withValues, offset = page.offset())

                    val preparedStatement = it.prepareStatement(sql)
                    withValues.forEachIndexed { index, id -> id.setter(index + 1, preparedStatement) }

                    val results = preparedStatement.executeQuery().use { resultSet ->
                        val collector = mutableListOf<T>()
                        while (resultSet.next()) {
                            collector.add(mapFrom(resultSet))
                        }
                        collector
                    }.asSequence()
                    page = page.next()
                    results
                }
            } else {
                null
            }
        }.flatten()
    }


    private data class Page(val number: Int, val size: Int, val total: Int) {
        fun next(): Page = copy(number = number + 1)

        fun offset() = (number * size)
    }

    fun all(): Sequence<T> {
        val count = countRows()
        var page = Page(number = 0, size = iterationPageSize, total = count)
        return generateSequence {
            if (page.offset() <= page.total) {
                dataSource.connection.use {
                    val sqlUpdate = selectByOffset(offset = page.offset())

                    val preparedStatement = it.prepareStatement(sqlUpdate)

                    val result = preparedStatement.executeQuery().use { resultSet ->
                        val collector = mutableListOf<T>()
                        while (resultSet.next()) {
                            collector.add(mapFrom(resultSet))
                        }
                        collector
                    }.asSequence()
                    page = page.next()
                    result
                }
            } else {
                null
            }
        }.flatten()
    }

    private fun selectByOffset(vararg withValues: ColumnValueSetter, offset: Int): String {
        val where = if (withValues.isNotEmpty()) {
            """WHERE ${withValues.map { "${it.column.name.value} = ${it.sqlValueString}" }.joinToString(" AND ")}"""
        } else {
            ""
        }
        return """ SELECT *
                        FROM $name
                        $where
                        LIMIT $iterationPageSize
                        Offset $offset
                """.trimIndent()
    }

    private fun countRows(): Int {
        return dataSource.connection.use {
            val sqlUpdate = """
                    SELECT count(*) as count
                        FROM $name """.trimIndent()

            val preparedStatement = it.prepareStatement(sqlUpdate)
            preparedStatement.executeQuery().use {
                it.next()
                it.getInt("count")
            }
        }
    }

    internal abstract fun mapTo(thing: T): Set<ColumnValueSetter>
    internal abstract fun mapFrom(resultSet: ResultSet): T
}

fun ResultSet.getNullableInt(columnLabel: String): Int? {
    return getObject(columnLabel)?.let { it as Int }
}
